/**
 * Helios Cloudflare Worker - ML-Optimized Brightness Algorithm
 * Version 5.2 FINAL - PROPRIETARY & CONFIDENTIAL
 * 
 * Copyright Â© 2025 Skyler Mydler / Killian Bleu. All rights reserved.
 * This code contains proprietary ML-optimized algorithms.
 * 
 * CHANGELOG v5.2:
 * - Fixed critical morning hours bug (date+hour matching)
 * - User authentication system with session management
 * - Database-backed city storage (max 6 cities per user)
 */

// ============================================================
// CONFIGURATION
// ============================================================

// Authentication token for ML algorithm access
const VALID_TOKENS = [
  'g4902tt2t02t2049t2g0235aegoebegg',  // Replace with your actual ML token
  // Add more tokens as needed for different users/apps
];

// Session duration for user authentication (62 days)
const SESSION_DURATION_DAYS = 62;

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// ============================================================
// SUNCALC LIBRARY (Embedded for solar calculations)
// ============================================================

const SunCalc = {
  getPosition: function(date, lat, lng) {
    const rad = Math.PI / 180;
    const dayMs = 1000 * 60 * 60 * 24;
    const J1970 = 2440588;
    const J2000 = 2451545;
    
    const toJulian = (date) => date.valueOf() / dayMs - 0.5 + J1970;
    const toDays = (date) => toJulian(date) - J2000;
    
    const e = rad * 23.4397;
    const lw = rad * -lng;
    const phi = rad * lat;
    const d = toDays(date);
    const M = rad * (357.5291 + 0.98560028 * d);
    const C = rad * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
    const P = rad * 102.9372;
    const L = M + C + P + Math.PI;
    const dec = Math.asin(Math.sin(L) * Math.sin(e));
    const RA = Math.atan2(Math.sin(L) * Math.cos(e), Math.cos(L));
    const theta = rad * (280.1600 + 360.9856235 * d) - lw;
    const H = theta - RA;
    const altitude = Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));
    const azimuth = Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(dec) * Math.cos(phi));
    
    return { altitude, azimuth };
  }
};

// ============================================================
// ML-OPTIMIZED ALGORITHM (v5.0 - PROPRIETARY)
// ============================================================

function getCloudBrightnessFactor(weatherCode) {
  const factors = {
    0: 1.16,   // Clear - ML optimized
    1: 1.14,   // Mainly clear - ML optimized
    2: 0.66,   // Partly cloudy - ML optimized
    3: 1.24,   // Overcast - ML optimized (+82%)
    45: 0.55,  // Fog
    48: 0.50,  // Rime fog
    51: 0.75,  // Light drizzle
    53: 0.70,  // Moderate drizzle
    55: 0.65,  // Dense drizzle
    61: 0.60,  // Slight rain
    63: 0.60,  // Moderate rain
    65: 0.50,  // Heavy rain
    71: 0.80,  // Slight snow
    73: 0.70,  // Moderate snow
    75: 0.60,  // Heavy snow
    77: 0.70,  // Snow grains
    80: 0.75,  // Rain showers
    81: 0.60,  // Heavy showers
    82: 0.45,  // Violent showers
    85: 0.75,  // Slight snow showers
    86: 0.60,  // Heavy snow showers
    95: 0.35,  // Thunderstorm
    96: 0.35,  // Thunderstorm + hail
    99: 0.35   // Severe storm
  };
  return factors[weatherCode] || 0.80;
}

function getPrecipitationFactor(weatherCode) {
  const factors = {
    0: 1.00, 1: 1.00, 2: 1.00, 3: 1.00, 45: 1.00, 48: 1.00,
    51: 0.90, 53: 0.80, 55: 0.70, 61: 0.85, 63: 0.70, 65: 0.55,
    71: 0.90, 73: 0.80, 75: 0.70, 77: 0.85, 80: 0.85, 81: 0.65,
    82: 0.50, 85: 0.85, 86: 0.70, 95: 0.45, 96: 0.45, 99: 0.45
  };
  return factors[weatherCode] || 1.00;
}

function getClarityFactor(weatherCode) {
  const factors = {
    0: 1.00, 1: 1.00, 2: 0.95, 3: 0.80, 45: 0.55, 48: 0.50,
    51: 0.90, 53: 0.85, 55: 0.85, 61: 0.85, 63: 0.80, 65: 0.70,
    71: 0.90, 73: 0.85, 75: 0.75, 77: 0.85, 80: 0.85, 81: 0.75,
    82: 0.60, 85: 0.85, 86: 0.75, 95: 0.65, 96: 0.65, 99: 0.65
  };
  return factors[weatherCode] || 1.00;
}

function getCloudCoverageFactor(cloudCover) {
  if (cloudCover < 10) return 1.00;
  if (cloudCover < 25) return 1.00;  // ML optimized
  if (cloudCover < 50) return 0.92;  // ML optimized
  if (cloudCover < 90) return 0.60;  // softened penalty for overcast
  return 0.58;                       // dense overcast cap
}

function calculateBrightnessScore(weatherCode, cloudCover, lat, lon, timestamp) {
  const sunPosition = SunCalc.getPosition(timestamp, lat, lon);
  const solarElevationDegrees = sunPosition.altitude * (180 / Math.PI);
  
  if (solarElevationDegrees <= 0) return 0;
  
  // Solar Elevation Factor
  let SEF;
  if (solarElevationDegrees < 2) {
    SEF = 0.5 + (solarElevationDegrees / 2) * 0.25;
  } else if (solarElevationDegrees < 8) {
    SEF = 0.75 + ((solarElevationDegrees - 2) / 6) * 0.15;
  } else {
    const normalizedElev = Math.min((solarElevationDegrees - 8) / 60, 1.0);
    SEF = 0.90 + (normalizedElev * 0.10);
  }
  
  const SEF_clamped = Math.max(0, Math.min(1, SEF));
  let SEF_adjusted = SEF_clamped;
  
  // Cloud dampening
  if (cloudCover > 85) {
    SEF_adjusted = SEF_clamped * 0.78;
  } else if (cloudCover > 60) {
    const dampening = 0.85 + ((85 - cloudCover) / 25) * 0.10;
    SEF_adjusted = SEF_clamped * dampening;
  }
  
  let CCF = getCloudCoverageFactor(cloudCover);
  const CBF = getCloudBrightnessFactor(weatherCode);
  const PF = getPrecipitationFactor(weatherCode);
  const ACF = getClarityFactor(weatherCode);
  
  // Error compensation
  const isThunderstorm = [95, 96, 99].includes(weatherCode);
  if (SEF_clamped > 0.7 && cloudCover > 60 && !isThunderstorm) {
    CCF = Math.min(1.0, CCF + 0.15);
  }
  
  const BrightnessRaw = SEF_adjusted * (
    0.40 * CCF + 0.30 * CBF + 0.15 * PF + 0.15 * ACF
  );
  
  let BrightnessRaw_clamped = Math.max(0, Math.min(1, BrightnessRaw));
  
  // Intelligent boost
  const needsBoost = (
    (SEF_adjusted > 0.75 && weatherCode === 3 && cloudCover > 75) ||
    (SEF_adjusted > 0.70 && weatherCode === 2 && cloudCover > 60)
  );
  
  if (needsBoost) {
    const boostAmount = SEF_adjusted > 0.80 ? 0.12 : 0.08;
    BrightnessRaw_clamped = Math.min(1.0, BrightnessRaw_clamped + boostAmount);
  }

  // Overcast-but-bright daytime bump (non-precipitating thick clouds)
  const precipCodes = new Set([51,53,55,61,63,65,71,73,75,77,80,81,82,85,86,95,96,99]);
  if (SEF_adjusted > 0.60 && cloudCover >= 80 && !precipCodes.has(weatherCode)) {
    BrightnessRaw_clamped = Math.min(1.0, BrightnessRaw_clamped + 0.10);
  }
  
  const HelioScore = BrightnessRaw_clamped * 5.0;
  return Math.max(0, Math.min(5, HelioScore));
}

// ============================================================
// WEATHER API INTEGRATION
// ============================================================

// Simple in-memory cache to avoid hammering weather APIs and hitting rate limits
// Cache stores current/hourly (30m) and daily (6h)
const weatherCache = new Map(); // key: `${lat},${lon},${tz}` -> { tsCurrent, tsDaily, data }
const TTL_CURRENT_MS = 30 * 60 * 1000; // 30 minutes
const TTL_DAILY_MS = 6 * 60 * 60 * 1000; // 6 hours

// Fallback provider: met.no (hourly + current; lightweight daily aggregates)
async function fetchFallbackMetNo(lat, lon, tz) {
  const url = `https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`;
  const resp = await fetch(url, { headers: { 'User-Agent': 'HeliosApp/1.0' } });
  if (!resp.ok) {
    const txt = await resp.text().catch(() => '');
    throw new Error(`Fallback weather error: ${resp.status} ${resp.statusText} body=${txt.slice(0,400)}`);
  }
  const data = await resp.json();
  const timeseries = data.properties?.timeseries || [];
  if (!timeseries.length) throw new Error('Fallback weather missing timeseries');

  const mapSymbol = (s) => {
    if (!s) return 0;
    if (s.includes('thunder')) return 95;
    if (s.includes('rain')) return 61;
    if (s.includes('snow')) return 71;
    if (s.includes('sleet')) return 75;
    if (s.includes('fog')) return 45;
    if (s.includes('cloudy')) return 3;
    if (s.includes('partly')) return 2;
    if (s.includes('fair')) return 1;
    return 0;
  };

  const hourly = { time: [], weather_code: [], cloud_cover: [], temperature_2m: [] };
  const dailyAgg = new Map(); // date -> { min, max, code }

  timeseries.forEach(ts => {
    const t = ts.time;
    const details = ts.data?.instant?.details || {};
    const symbol = ts.data?.next_1_hours?.summary?.symbol_code || ts.data?.next_6_hours?.summary?.symbol_code || '';
    const weatherCode = mapSymbol(symbol);
    const cloud = details.cloud_area_fraction ?? null;
    const temp = details.air_temperature ?? null;

    hourly.time.push(t);
    hourly.weather_code.push(weatherCode);
    hourly.cloud_cover.push(cloud);
    hourly.temperature_2m.push(temp);

    const date = t.slice(0,10);
    const agg = dailyAgg.get(date) || { min: temp, max: temp, code: weatherCode };
    agg.min = (agg.min == null || temp < agg.min) ? temp : agg.min;
    agg.max = (agg.max == null || temp > agg.max) ? temp : agg.max;
    // keep first code of day
    dailyAgg.set(date, agg);
  });

  const dailyDates = Array.from(dailyAgg.keys()).sort();
  const daily = {
    sunrise: dailyDates.map(() => null),
    sunset: dailyDates.map(() => null),
    weather_code: dailyDates.map(d => dailyAgg.get(d).code ?? null),
    temperature_2m_max: dailyDates.map(d => dailyAgg.get(d).max ?? null),
    temperature_2m_min: dailyDates.map(d => dailyAgg.get(d).min ?? null),
    daylight_duration: dailyDates.map(() => null)
  };

  // Current from first element
  const first = timeseries[0];
  const firstDetails = first.data?.instant?.details || {};
  const firstSymbol = first.data?.next_1_hours?.summary?.symbol_code || first.data?.next_6_hours?.summary?.symbol_code || '';
  const currentCode = mapSymbol(firstSymbol);
  const currentCloud = firstDetails.cloud_area_fraction ?? null;

  return {
    current: {
      weather_code: currentCode,
      cloud_cover: currentCloud,
      temperature_2m: firstDetails.air_temperature ?? null
    },
    hourly,
    daily,
    timezone: tz || 'auto'
  };
}

async function fetchOpenMeteo(lat, lon, tz, includeDaily=true) {
  const dailyParams = includeDaily ? '&daily=weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,daylight_duration&forecast_days=7' : '';
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=weather_code,cloud_cover,temperature_2m&hourly=weather_code,cloud_cover,temperature_2m${dailyParams}&timezone=${tz || 'auto'}`;
  const resp = await fetch(url);
  if (!resp.ok) {
    const text = await resp.text().catch(() => '');
    throw new Error(`Weather API error: ${resp.status} ${resp.statusText} url=${url} body=${text.slice(0,400)}`);
  }
  return resp.json();
}

async function fetchWeatherData(lat, lon, timezone) {
  const tz = timezone || 'auto';
  const key = `${lat},${lon},${tz}`;
  const now = Date.now();
  const cached = weatherCache.get(key);
  const currentFresh = cached && (now - cached.tsCurrent) < TTL_CURRENT_MS;
  const dailyFresh = cached && (now - cached.tsDaily) < TTL_DAILY_MS;

  // If both fresh, return cached
  if (currentFresh && dailyFresh) {
    return cached.data;
  }

  try {
    // If daily is fresh but current is stale, try current-only fetch to reduce load
    if (!currentFresh && dailyFresh) {
      const fresh = await fetchOpenMeteo(lat, lon, tz, false);
      const merged = {
        ...cached.data,
        current: fresh.current || cached.data.current,
        hourly: fresh.hourly || cached.data.hourly,
      };
      weatherCache.set(key, { tsCurrent: now, tsDaily: cached.tsDaily, data: merged });
      return merged;
    }

    // Otherwise fetch full (current+hourly+daily)
    const data = await fetchOpenMeteo(lat, lon, tz, true);
    weatherCache.set(key, { tsCurrent: now, tsDaily: now, data });
    return data;
  } catch (err) {
    console.error('Open-Meteo error:', err.message);
    // Fallback to met.no if open-meteo fails
    try {
      const fb = await fetchFallbackMetNo(lat, lon, tz);
      const merged = cached ? {
        ...cached.data,
        current: fb.current,
        hourly: fb.hourly,
        daily: cached.data.daily,
        timezone: fb.timezone
      } : fb;
      weatherCache.set(key, { tsCurrent: now, tsDaily: cached?.tsDaily || now, data: merged });
      return merged;
    } catch (fallbackErr) {
      console.error('Fallback provider failed:', fallbackErr.message);
      if (cached) {
        console.warn('Serving stale cache after fallback failure');
        return cached.data;
      }
      throw fallbackErr;
    }
  }
}

function calculateScores(weatherData, lat, lon, timezone) {
  const current = weatherData.current;
  const hourly = weatherData.hourly;
  const daily = weatherData.daily;
  
  // Comprehensive timezone offset lookup (in hours from UTC)
  const timezoneOffsets = {
    // Americas
    'America/New_York': -5, 'America/Detroit': -5, 'America/Kentucky/Louisville': -5,
    'America/Chicago': -6, 'America/Denver': -7, 'America/Phoenix': -7,
    'America/Los_Angeles': -8, 'America/Anchorage': -9, 'America/Juneau': -9,
    'Pacific/Honolulu': -10, 'America/Adak': -10,
    'America/Toronto': -5, 'America/Montreal': -5, 'America/Vancouver': -8,
    'America/Edmonton': -7, 'America/Winnipeg': -6, 'America/Halifax': -4,
    'America/St_Johns': -3.5,
    'America/Sao_Paulo': -3, 'America/Argentina/Buenos_Aires': -3,
    'America/Santiago': -4, 'America/Lima': -5, 'America/Bogota': -5,
    'America/Mexico_City': -6, 'America/Guatemala': -6, 'America/Managua': -6,
    'America/Caracas': -4, 'America/La_Paz': -4, 'America/Guayaquil': -5,
    
    // Europe
    'Europe/London': 0, 'Europe/Dublin': 0, 'Europe/Lisbon': 0,
    'Europe/Paris': 1, 'Europe/Berlin': 1, 'Europe/Rome': 1, 'Europe/Madrid': 1,
    'Europe/Amsterdam': 1, 'Europe/Brussels': 1, 'Europe/Vienna': 1,
    'Europe/Stockholm': 1, 'Europe/Oslo': 1, 'Europe/Copenhagen': 1,
    'Europe/Warsaw': 1, 'Europe/Prague': 1, 'Europe/Budapest': 1,
    'Europe/Athens': 2, 'Europe/Bucharest': 2, 'Europe/Helsinki': 2,
    'Europe/Istanbul': 3, 'Europe/Moscow': 3, 'Europe/Kiev': 2,
    
    // Africa
    'Africa/Cairo': 2, 'Africa/Johannesburg': 2, 'Africa/Lagos': 1,
    'Africa/Nairobi': 3, 'Africa/Casablanca': 1, 'Africa/Algiers': 1,
    
    // Middle East
    'Asia/Dubai': 4, 'Asia/Riyadh': 3, 'Asia/Qatar': 3, 'Asia/Bahrain': 3,
    'Asia/Kuwait': 3, 'Asia/Jerusalem': 2, 'Asia/Beirut': 2, 'Asia/Baghdad': 3,
    'Asia/Tehran': 3.5,
    
    // Asia
    'Asia/Kolkata': 5.5, 'Asia/Mumbai': 5.5, 'Asia/Delhi': 5.5,
    'Asia/Dhaka': 6, 'Asia/Karachi': 5, 'Asia/Kabul': 4.5,
    'Asia/Kathmandu': 5.75, 'Asia/Colombo': 5.5,
    'Asia/Bangkok': 7, 'Asia/Jakarta': 7, 'Asia/Ho_Chi_Minh': 7,
    'Asia/Singapore': 8, 'Asia/Kuala_Lumpur': 8, 'Asia/Manila': 8,
    'Asia/Hong_Kong': 8, 'Asia/Shanghai': 8, 'Asia/Beijing': 8,
    'Asia/Taipei': 8, 'Asia/Tokyo': 9, 'Asia/Seoul': 9,
    'Asia/Yangon': 6.5, 'Asia/Ulaanbaatar': 8,
    
    // Australia & Pacific
    'Australia/Sydney': 11, 'Australia/Melbourne': 11, 'Australia/Canberra': 11,
    'Australia/Brisbane': 10, 'Australia/Adelaide': 10.5, 'Australia/Darwin': 9.5,
    'Australia/Perth': 8, 'Australia/Hobart': 11,
    'Pacific/Auckland': 13, 'Pacific/Fiji': 12, 'Pacific/Guam': 10,
    'Pacific/Port_Moresby': 10, 'Pacific/Noumea': 11, 'Pacific/Tahiti': -10,
    'Pacific/Pago_Pago': -11, 'Pacific/Midway': -11,
    
    // Additional US Cities
    'America/Boise': -7, 'America/Indiana/Indianapolis': -5,
    'America/Kentucky/Monticello': -5, 'America/North_Dakota/Center': -6,
    
    // Additional Canadian Cities  
    'America/Regina': -6, 'America/Saskatoon': -6,
    
    // Additional timezones
    'Atlantic/Reykjavik': 0, 'Atlantic/Azores': -1, 'Atlantic/Cape_Verde': -1,
    'Indian/Maldives': 5, 'Indian/Mauritius': 4,
    
    // US Territories
    'Pacific/Guam': 10, 'Pacific/Saipan': 10, 'America/Puerto_Rico': -4,
    'America/Virgin': -4
  };
  
  const tzOffset = timezoneOffsets[timezone] || 0;
  
  // Helper: Convert local time string to actual UTC Date
  function localTimeToRealUTC(localTimeStr) {
    const match = localTimeStr.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):?(\d{2})?/);
    if (!match) {
      return new Date(localTimeStr);
    }
    
    const [_, year, month, day, hour, minute, second] = match;
    
    const localDate = new Date(
      parseInt(year),
      parseInt(month) - 1,
      parseInt(day),
      parseInt(hour),
      parseInt(minute),
      parseInt(second || '0')
    );
    
    const utcTime = localDate.getTime() + (-tzOffset * 3600000);
    return new Date(utcTime);
  }
  
  // Current score
  const currentTime = localTimeToRealUTC(current.time);
  const currentScore = calculateBrightnessScore(
    current.weather_code,
    current.cloud_cover,
    lat,
    lon,
    currentTime
  );
  
  // ============================================================
  // CRITICAL BUGFIX v5.2: Match BOTH date AND hour
  // ============================================================
  const currentTimeStr = current.time; // e.g., "2025-12-19T07:00"
  
  // Find the index in hourly array that matches current date and hour
  let startIndex = 0;
  for (let i = 0; i < hourly.time.length; i++) {
    // Match both date and hour to avoid morning issues with past data
    if (hourly.time[i].startsWith(currentTimeStr.substring(0, 13))) { // Match "YYYY-MM-DDTHH"
      startIndex = i;
      break;
    }
  }
  
  // Fallback: if no exact match found (edge case), find first future hour
  if (startIndex === 0 && hourly.time.length > 0) {
    const currentDate = new Date(currentTimeStr);
    for (let i = 0; i < hourly.time.length; i++) {
      const hourDate = new Date(hourly.time[i]);
      if (hourDate >= currentDate) {
        startIndex = i;
        break;
      }
    }
  }
  // ============================================================
  
  // Process ALL hours available
  const allHourlyScores = [];
  for (let i = 0; i < hourly.time.length; i++) {
    try {
      const time = localTimeToRealUTC(hourly.time[i]);
      const score = calculateBrightnessScore(
        hourly.weather_code[i],
        hourly.cloud_cover[i],
        lat,
        lon,
        time
      );
      
      allHourlyScores.push({
        time: hourly.time[i],
        score: Math.round(score * 10) / 10,
        temperature: Math.round(hourly.temperature_2m[i] * 9/5 + 32),
        weatherCode: hourly.weather_code[i],
        cloudCover: hourly.cloud_cover[i]
      });
    } catch (err) {
      console.error('Error processing hour', i, err);
    }
  }
  
  const todayHourlyScores = allHourlyScores.slice(0, Math.min(24, allHourlyScores.length));
  const endIndex = Math.min(startIndex + 24, allHourlyScores.length);
  const hourlyForecast = allHourlyScores.slice(startIndex, endIndex);
  
  const todayDaylightScores = todayHourlyScores.filter(h => h.score > 0);
  const dailyAvg = todayDaylightScores.length > 0
    ? todayDaylightScores.reduce((sum, h) => sum + h.score, 0) / todayDaylightScores.length
    : 0;
  
  const daylightHours = daily.daylight_duration ? Math.round(daily.daylight_duration[0] / 3600 * 10) / 10 : 0;
  
  // 7-day forecast with peak times
  const weekForecast = [];
  for (let i = 0; i < Math.min(7, daily.time.length); i++) {
    const dayScores = [];
    const dayScoresWithTime = [];
    const startHour = i * 24;
    
    for (let h = startHour; h < startHour + 24 && h < hourly.time.length; h++) {
      const time = localTimeToRealUTC(hourly.time[h]);
      const score = calculateBrightnessScore(
        hourly.weather_code[h],
        hourly.cloud_cover[h],
        lat,
        lon,
        time
      );
      
      if (score > 0) {
        const hourMatch = hourly.time[h].match(/T(\d{2}):/);
        const localHour = hourMatch ? parseInt(hourMatch[1]) : 12;
        
        dayScores.push(score);
        dayScoresWithTime.push({ 
          score, 
          hour: localHour, 
          weatherCode: hourly.weather_code[h] 
        });
      }
    }
    
    const avgScore = dayScores.length > 0
      ? dayScores.reduce((a, b) => a + b, 0) / dayScores.length
      : 0;
    
    let peakScore = 0;
    let peakHour = 12;
    if (dayScoresWithTime.length > 0) {
      const sorted = dayScoresWithTime.sort((a, b) => {
        if (Math.abs(a.score - b.score) < 0.3) {
          if (a.weatherCode < b.weatherCode) return -1;
          if (a.weatherCode > b.weatherCode) return 1;
        }
        return b.score - a.score;
      });
      peakScore = sorted[0].score;
      peakHour = sorted[0].hour;
    }
    
    const dayDaylightHours = daily.daylight_duration ? Math.round(daily.daylight_duration[i] / 3600 * 10) / 10 : 0;
    
    weekForecast.push({
      date: daily.time[i],
      avgScore: Math.round(avgScore * 10) / 10,
      peakScore: Math.round(peakScore * 10) / 10,
      peakHour: peakHour,
      maxTemp: Math.round(daily.temperature_2m_max[i] * 9/5 + 32),
      minTemp: Math.round(daily.temperature_2m_min[i] * 9/5 + 32),
      weatherCode: daily.weather_code[i],
      sunrise: daily.sunrise[i],
      sunset: daily.sunset[i],
      daylightHours: dayDaylightHours
    });
  }
  
  return {
    currentScore: Math.round(currentScore * 10) / 10,
    currentTemp: Math.round(current.temperature_2m * 9/5 + 32),
    currentWeatherCode: current.weather_code,
    currentCloudCover: current.cloud_cover,
    dailyAverage: Math.round(dailyAvg * 10) / 10,
    daylightHours: daylightHours,
    sunrise: daily.sunrise[0],
    sunset: daily.sunset[0],
    todayHourlyScores: todayHourlyScores,
    hourlyForecast: hourlyForecast,
    weekForecast: weekForecast,
    timezone: weatherData.timezone
  };
}

// ============================================================
// ML CALCULATION HANDLER
// ============================================================

async function handleCalculate(request) {
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }
  
  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return new Response(JSON.stringify({ error: 'Missing authorization' }), {
      status: 401,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
  
  const token = authHeader.substring(7);
  if (!VALID_TOKENS.includes(token)) {
    return new Response(JSON.stringify({ error: 'Invalid token' }), {
      status: 401,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
  
  try {
    const body = await request.json();
    const { latitude, longitude, cityName, timezone } = body;
    
    if (!latitude || !longitude) {
      return new Response(JSON.stringify({ error: 'Missing coordinates' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
    
    const tz = timezone || 'auto';
    const weatherData = await fetchWeatherData(latitude, longitude, tz);
    
    let scores;
    try {
      scores = calculateScores(weatherData, latitude, longitude, tz);
    } catch (calcError) {
      console.error('Score calculation error:', calcError.message);
      console.error('City:', cityName, 'TZ:', tz);
      console.error('Stack:', calcError.stack);
      return new Response(JSON.stringify({ 
        error: 'Score calculation failed',
        message: calcError.message,
        stack: calcError.stack,
        timezone: tz,
        city: cityName
      }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
    
    return new Response(JSON.stringify({
      city: cityName || 'Unknown',
      ...scores
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    const isRateLimit = error.message && error.message.includes('429');
    return new Response(JSON.stringify({ 
      error: error.message,
      stack: error.stack,
      name: error.name,
      rate_limit: isRateLimit
    }), {
      status: isRateLimit ? 429 : 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

// ============================================================
// USER AUTHENTICATION SYSTEM
// ============================================================

async function hashPassword(password) {
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function verifyPassword(password, hash) {
    const passwordHash = await hashPassword(password);
    return passwordHash === hash;
}

function generateToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

async function getUserFromToken(db, token) {
    if (!token) return null;
    
    const session = await db.prepare(
        'SELECT user_id, expires_at FROM sessions WHERE token = ?'
    ).bind(token).first();
    
    if (!session) return null;
    
    const now = new Date();
    const expiresAt = new Date(session.expires_at);
    if (now > expiresAt) {
        await db.prepare('DELETE FROM sessions WHERE token = ?').bind(token).run();
        return null;
    }
    
    const user = await db.prepare(
        'SELECT id, username FROM users WHERE id = ?'
    ).bind(session.user_id).first();
    
    return user;
}

async function handleSignup(request, env) {
    try {
        const { username, password } = await request.json();
        
        if (!username || !password) {
            return new Response(JSON.stringify({ error: 'Username and password required' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        if (username.length < 3 || username.length > 20) {
            return new Response(JSON.stringify({ error: 'Username must be 3-20 characters' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        if (password.length < 6) {
            return new Response(JSON.stringify({ error: 'Password must be at least 6 characters' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const usernameLower = username.toLowerCase();
        
        const existing = await env.DB.prepare(
            'SELECT id FROM users WHERE LOWER(username) = ?'
        ).bind(usernameLower).first();
        
        if (existing) {
            return new Response(JSON.stringify({ error: 'Username already taken' }), {
                status: 409,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const passwordHash = await hashPassword(password);
        const result = await env.DB.prepare(
            'INSERT INTO users (username, password_hash) VALUES (?, ?)'
        ).bind(usernameLower, passwordHash).run();
        
        const userId = result.meta.last_row_id;
        
        const token = generateToken();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + SESSION_DURATION_DAYS);
        
        await env.DB.prepare(
            'INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)'
        ).bind(userId, token, expiresAt.toISOString()).run();
        
        return new Response(JSON.stringify({ 
            success: true, 
            token,
            username: usernameLower,
            mlToken: VALID_TOKENS[0]
        }), {
            status: 201,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Signup error:', error);
        return new Response(JSON.stringify({ error: 'Server error' }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
    }
}

async function handleLogin(request, env) {
    try {
        const { username, password } = await request.json();
        
        if (!username || !password) {
            return new Response(JSON.stringify({ error: 'Username and password required' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const usernameLower = username.toLowerCase();
        
        const user = await env.DB.prepare(
            'SELECT id, username, password_hash FROM users WHERE LOWER(username) = ?'
        ).bind(usernameLower).first();
        
        if (!user) {
            return new Response(JSON.stringify({ error: 'Invalid username or password' }), {
                status: 401,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const valid = await verifyPassword(password, user.password_hash);
        if (!valid) {
            return new Response(JSON.stringify({ error: 'Invalid username or password' }), {
                status: 401,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const token = generateToken();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + SESSION_DURATION_DAYS);
        
        await env.DB.prepare(
            'INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)'
        ).bind(user.id, token, expiresAt.toISOString()).run();
        
        return new Response(JSON.stringify({ 
            success: true, 
            token,
            username: user.username,
            mlToken: VALID_TOKENS[0]
        }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Login error:', error);
        return new Response(JSON.stringify({ error: 'Server error' }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
    }
}

async function handleLogout(request, env) {
    try {
        const token = request.headers.get('Authorization')?.replace('Bearer ', '');
        
        if (token) {
            await env.DB.prepare('DELETE FROM sessions WHERE token = ?').bind(token).run();
        }
        
        return new Response(JSON.stringify({ success: true }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Logout error:', error);
        return new Response(JSON.stringify({ error: 'Server error' }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
    }
}

async function handleGetCities(request, env) {
    try {
        const token = request.headers.get('Authorization')?.replace('Bearer ', '');
        const user = await getUserFromToken(env.DB, token);
        
        if (!user) {
            return new Response(JSON.stringify({ error: 'Unauthorized' }), {
                status: 401,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const cities = await env.DB.prepare(
            'SELECT city_name, latitude, longitude, timezone, admin1, country FROM user_cities WHERE user_id = ? ORDER BY display_order'
        ).bind(user.id).all();
        
        return new Response(JSON.stringify({ 
            cities: cities.results || []
        }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Get cities error:', error);
        return new Response(JSON.stringify({ error: error.message || 'Server error' }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
    }
}

async function handleSaveCities(request, env) {
    try {
        const token = request.headers.get('Authorization')?.replace('Bearer ', '');
        const user = await getUserFromToken(env.DB, token);
        
        if (!user) {
            return new Response(JSON.stringify({ error: 'Unauthorized' }), {
                status: 401,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        const { cities } = await request.json();
        
        if (!Array.isArray(cities)) {
            return new Response(JSON.stringify({ error: 'Cities must be an array' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        if (cities.length > 6) {
            return new Response(JSON.stringify({ error: 'Maximum 6 cities allowed' }), {
                status: 400,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
        
        await env.DB.prepare('DELETE FROM user_cities WHERE user_id = ?').bind(user.id).run();
        
        for (let i = 0; i < cities.length; i++) {
            const city = cities[i];
            await env.DB.prepare(
                'INSERT INTO user_cities (user_id, city_name, latitude, longitude, timezone, admin1, country, display_order) VALUES (?, ?, ?, ?, ?, ?, ?, ?)'
            ).bind(
                user.id,
                city.city_name,
                city.latitude,
                city.longitude,
                city.timezone || 'auto',
                city.admin1 || '',
                city.country || '',
                i
            ).run();
        }
        
        return new Response(JSON.stringify({ success: true }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Save cities error:', error);
        return new Response(JSON.stringify({ error: error.message || 'Server error' }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
    }
}

// ============================================================
// EXPORT
// ============================================================

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }
    
    if (url.pathname === '/auth/signup' && request.method === 'POST') {
      return handleSignup(request, env);
    }
    
    if (url.pathname === '/auth/login' && request.method === 'POST') {
      return handleLogin(request, env);
    }
    
    if (url.pathname === '/auth/logout' && request.method === 'POST') {
      return handleLogout(request, env);
    }
    
    if (url.pathname === '/user/cities' && request.method === 'GET') {
      return handleGetCities(request, env);
    }
    
    if (url.pathname === '/user/cities' && request.method === 'POST') {
      return handleSaveCities(request, env);
    }
    
    if (url.pathname === '/calculate') {
      return handleCalculate(request);
    }
    
    return new Response('Helios API v5.2 - Production', {
      headers: { ...corsHeaders, 'Content-Type': 'text/plain' }
    });
  }
};
