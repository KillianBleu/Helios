<!--
Helios - Sunshine Weather App (Public UI)
Version 5.0 
Copyright ¬© 2025 Skyler Mydler / Killian Bleu. All rights reserved.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helios - Sunshine Weather</title>
    <style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .header p {
            font-size: 18px;
            opacity: 0.95;
        }

        .back-button {
            display: none;
            background: white;
            color: #FFA500;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .back-button:hover {
            transform: translateY(-2px);
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-box {
            display: flex;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #searchInput {
            flex: 1;
            padding: 18px 20px;
            border: none;
            font-size: 16px;
            outline: none;
        }

        #searchBtn {
            padding: 18px 30px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: none;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        #searchBtn:hover {
            opacity: 0.9;
        }

        #searchResults {
            display: none;
            background: white;
            border-radius: 12px;
            margin-top: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            overflow: hidden;
            position: absolute;
            width: 100%;
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
        }

        .search-result-item {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: #FFF9F0;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item strong {
            color: #333;
            font-weight: 600;
            display: block;
            margin-bottom: 3px;
        }

        .search-result-item .city-details {
            font-size: 14px;
            color: #999;
        }

        /* Icon styles */
        .icon {
            width: 24px;
            height: 24px;
            display: inline-block;
            vertical-align: middle;
        }

        .icon-sm {
            width: 16px;
            height: 16px;
        }

        .icon-lg {
            width: 32px;
            height: 32px;
        }

        /* City Cards View */
        #citiesView {
            display: block;
        }

        .cities-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .city-card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .city-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }

        .city-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 12px;
        }

        .city-info {
            flex: 1;
        }

        .city-name {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .city-country {
            font-size: 12px;
            color: #999;
        }

        .current-helio-compact {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 12px;
        }

        .helio-score-compact {
            font-size: 36px;
            font-weight: 700;
            line-height: 1;
        }

        .helio-score-compact.excellent { color: #FFD700; }
        .helio-score-compact.good { color: #FFA500; }
        .helio-score-compact.fair { color: #FF8C00; }
        .helio-score-compact.poor { color: #FF6347; }
        .helio-score-compact.very-poor { color: #8B4513; }
        .helio-score-compact.nighttime { color: #1a237e; }

        .score-label-compact {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 2px;
        }

        .delete-city {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #ccc;
            padding: 4px;
            transition: color 0.2s;
            position: absolute;
            top: 12px;
            right: 12px;
        }

        .delete-city:hover {
            color: #ff4444;
        }

        .card-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 8px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .stat-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: white;
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        /* Detail View */
        #detailView {
            display: none;
        }

        .detail-card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .detail-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .detail-city-name {
            font-size: 28px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .helio-score-large {
            font-size: 72px;
            font-weight: 700;
            margin: 20px 0;
        }

        .helio-score-large.excellent { color: #FFD700; }
        .helio-score-large.good { color: #FFA500; }
        .helio-score-large.fair { color: #FF8C00; }
        .helio-score-large.poor { color: #FF6347; }
        .helio-score-large.very-poor { color: #8B4513; }
        .helio-score-large.nighttime { color: #1a237e; }

        .score-label {
            font-size: 18px;
            color: #666;
            margin-bottom: 20px;
        }

        .weather-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .detail-item {
            text-align: center;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 12px;
        }

        .detail-label {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .detail-value {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: start;
            gap: 10px;
        }

        /* Sunshine Pattern Bar */
        .pattern-times {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }

        .pattern-bar {
            display: flex;
            height: 50px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .pattern-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: transform 0.2s;
        }

        .pattern-segment:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .pattern-segment.sunny { background: #FFD93D; }
        .pattern-segment.partly-cloudy { background: #FFB347; }
        .pattern-segment.cloudy { background: #B0E0E6; }
        .pattern-segment.rainy { background: #5B9BD5; }
        .pattern-segment.night { background: #1a237e; }

        .pattern-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 13px;
            color: #666;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 10px;
            gap: 12px;
        }

        .timeline-time {
            font-weight: 600;
            color: #333;
            min-width: 80px;
        }

        .timeline-event {
            flex: 1;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hourly-forecast {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .hourly-item {
            min-width: 90px;
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            flex-shrink: 0;
        }

        .hourly-item.daytime {
            background: rgba(255, 179, 71, 0.15);
            border: 1px solid rgba(255, 179, 71, 0.3);
        }

        .hourly-item.nighttime {
            background: rgba(26, 35, 126, 0.15);
            border: 1px solid rgba(26, 35, 126, 0.3);
        }

        .hourly-time {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .hourly-icon {
            margin: 10px 0;
            display: flex;
            justify-content: center;
        }

        .hourly-score {
            font-size: 24px;
            font-weight: 700;
            margin: 8px 0;
        }

        .hourly-temp {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
        }

        .daily-forecast {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .daily-item {
            display: flex;
            align-items: center;
            padding: 18px;
            border-radius: 12px;
            background: linear-gradient(135deg, #fff 0%, #fafafa 100%);
            border: 1px solid #e0e0e0;
            transition: all 0.2s;
        }

        .daily-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .daily-item.excellent-day {
            background: linear-gradient(135deg, #FFF9E6 0%, #FFF5CC 100%);
            border-color: #FFD700;
        }

        .daily-item.good-day {
            background: linear-gradient(135deg, #FFF5E6 0%, #FFEDCC 100%);
            border-color: #FFA500;
        }

        .daily-day {
            font-weight: 600;
            color: #333;
            min-width: 100px;
        }

        .daily-score {
            font-size: 24px;
            font-weight: 700;
            margin: 0 20px;
        }

        .daily-summary {
            flex: 1;
            color: #666;
            font-size: 14px;
        }

        .daily-description {
            color: #888;
            font-size: 13px;
            margin-top: 4px;
            font-style: italic;
        }

        .copyright {
            text-align: center;
            color: white;
            margin-top: 30px;
            font-size: 14px;
            opacity: 0.8;
        }

        /* Scrollbar styling */
        .hourly-forecast::-webkit-scrollbar {
            height: 8px;
        }

        .hourly-forecast::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .hourly-forecast::-webkit-scrollbar-thumb {
            background: #FFB347;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                    <line x1="1" y1="12" x2="3" y2="12"/>
                    <line x1="21" y1="12" x2="23" y2="12"/>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
    </style>
</head>
<body>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </svg>
                Helios
            </h1>
            <p>Your Sunshine Forecast</p>
        </div>

        <button class="back-button" id="backButton" onclick="showCitiesView()">&larr;¬ê Back to Cities</button>

        <div class="search-container">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search for a city..." autocomplete="off">
                <button id="searchBtn">Search</button>
            </div>
            <div id="searchResults"></div>
        </div>

        <!-- Cities View -->
        <div id="citiesView">
            <div class="empty-state" id="emptyState">
                <h2>Welcome to Helios</h2>
                <p>Search for a city to add it to your dashboard</p>
            </div>
            <div class="cities-grid" id="citiesGrid"></div>
        </div>

        <!-- Detail View -->
        <div id="detailView">
            <div class="detail-card">
                <div class="detail-header">
                    <div class="detail-city-name" id="detailCityName">Loading...</div>
                    <div class="helio-score-large" id="detailHelioScore">-</div>
                    <div class="score-label" id="detailScoreLabel">Calculating...</div>
                    <div class="weather-details" id="detailWeatherDetails"></div>
                </div>
            </div>

            <div class="detail-card">
                <div class="section-title">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    Today's Sunshine Pattern
                </div>
                <div class="pattern-times" id="patternTimes"></div>
                <div class="pattern-bar" id="patternBar"></div>
                <div class="pattern-legend" id="patternLegend"></div>
            </div>

            <div class="detail-card">
                <div class="section-title">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3v18h18"/>
                        <path d="M18 17V9"/>
                        <path d="M13 17V5"/>
                        <path d="M8 17v-3"/>
                    </svg>
                    Hourly Forecast
                </div>
                <div class="hourly-forecast" id="hourlyForecast"></div>
            </div>

            <div class="detail-card">
                <div class="section-title">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    7-Day Forecast
                </div>
                <div class="daily-forecast" id="dailyForecast"></div>
            </div>
        </div>

        <div class="copyright">
            ¬© 2025 Helios Weather App. All rights reserved.
        </div>
    </div>

    <script>
        // SVG Icon Templates
        const icons = {
            sun: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>',
            partlyCloudy: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/><path d="M22 15.5c-1.5 0-2.5-1-3-2s-1.5-2-3-2c-1.5 0-2.5 1-3 2"/></svg>',
            cloudy: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
            rainy: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 13v8"/><path d="M8 13v8"/><path d="M12 15v8"/><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"/></svg>',
            snow: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"/><line x1="8" y1="16" x2="8.01" y2="16"/><line x1="8" y1="20" x2="8.01" y2="20"/><line x1="12" y1="18" x2="12.01" y2="18"/><line x1="12" y1="22" x2="12.01" y2="22"/><line x1="16" y1="16" x2="16.01" y2="16"/><line x1="16" y1="20" x2="16.01" y2="20"/></svg>',
            storm: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2 3 14h9l-1 8 10-12h-9l1-8z"/></svg>',
            moon: '<svg class="icon-lg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>',
            sunrise: '<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v8"/><path d="m4.93 10.93 1.41 1.41"/><path d="M2 18h2"/><path d="M20 18h2"/><path d="m19.07 10.93-1.41 1.41"/><path d="M22 22H2"/><path d="m8 6 4-4 4 4"/></svg>',
            sunset: '<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 10V2"/><path d="m4.93 10.93 1.41 1.41"/><path d="M2 18h2"/><path d="M20 18h2"/><path d="m19.07 10.93-1.41 1.41"/><path d="M22 22H2"/><path d="m16 6-4 4-4-4"/></svg>',
            thermometer: '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"/></svg>',
            cloud: '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>',
            droplet: '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>'
        };

        let searchTimeout;
        let savedCities = [];
        
        // Load saved cities and filter out any with missing weather data
        try {
            const stored = JSON.parse(localStorage.getItem('heliosCities') || '[]');
            savedCities = stored.filter(city => city.weatherData && city.weatherData.daily && city.weatherData.hourly);
            // Save back the filtered list
            if (stored.length !== savedCities.length) {
                localStorage.setItem('heliosCities', JSON.stringify(savedCities));
            }
        } catch (e) {
            console.error('Error loading saved cities:', e);
            savedCities = [];
            localStorage.setItem('heliosCities', '[]');
        }

        // Weather code mapping
        const weatherCodes = {
            0: { name: 'Clear', icon: icons.sun, type: 'sunny' },
            1: { name: 'Mainly Clear', icon: icons.partlyCloudy, type: 'sunny' },
            2: { name: 'Partly Cloudy', icon: icons.partlyCloudy, type: 'partly-cloudy' },
            3: { name: 'Overcast', icon: icons.cloudy, type: 'cloudy' },
            45: { name: 'Foggy', icon: icons.cloudy, type: 'cloudy' },
            48: { name: 'Foggy', icon: icons.cloudy, type: 'cloudy' },
            51: { name: 'Light Drizzle', icon: icons.rainy, type: 'rainy' },
            53: { name: 'Drizzle', icon: icons.rainy, type: 'rainy' },
            55: { name: 'Heavy Drizzle', icon: icons.rainy, type: 'rainy' },
            61: { name: 'Light Rain', icon: icons.rainy, type: 'rainy' },
            63: { name: 'Rain', icon: icons.rainy, type: 'rainy' },
            65: { name: 'Heavy Rain', icon: icons.rainy, type: 'rainy' },
            71: { name: 'Light Snow', icon: icons.snow, type: 'rainy' },
            73: { name: 'Snow', icon: icons.snow, type: 'rainy' },
            75: { name: 'Heavy Snow', icon: icons.snow, type: 'rainy' },
            80: { name: 'Rain Showers', icon: icons.rainy, type: 'rainy' },
            81: { name: 'Rain Showers', icon: icons.rainy, type: 'rainy' },
            82: { name: 'Heavy Showers', icon: icons.rainy, type: 'rainy' },
            95: { name: 'Thunderstorm', icon: icons.storm, type: 'rainy' },
            96: { name: 'Thunderstorm', icon: icons.storm, type: 'rainy' },
            99: { name: 'Severe Storm', icon: icons.storm, type: 'rainy' }
        };

        // Get day name from date string in correct timezone
        function getDayName(dateString, isToday) {
            if (isToday) return 'Today';
            
            // Parse the date string (format: "2025-12-16")
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(year, month - 1, day); // Month is 0-indexed
            
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            return days[date.getDay()];
        }

        // Time parsing functions
        function parseLocalTime(timeStr) {
            const parts = timeStr.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
            if (!parts) return null;
            return {
                year: parseInt(parts[1]),
                month: parseInt(parts[2]),
                day: parseInt(parts[3]),
                hour: parseInt(parts[4]),
                minute: parseInt(parts[5])
            };
        }

        function getCurrentLocalTime(timezone) {
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            
            const parts = formatter.formatToParts(new Date());
            const getValue = (type) => parts.find(p => p.type === type)?.value;
            
            return {
                year: parseInt(getValue('year')),
                month: parseInt(getValue('month')),
                day: parseInt(getValue('day')),
                hour: parseInt(getValue('hour')),
                minute: parseInt(getValue('minute'))
            };
        }

        function toMinutes(time) {
            return time.hour * 60 + time.minute;
        }

        function isDaytime(currentMinutes, sunriseMinutes, sunsetMinutes) {
            return currentMinutes >= sunriseMinutes && currentMinutes < sunsetMinutes;
        }

        // Create proper timestamp from API's ISO time string
        // API gives us "2024-12-15T11:00" which represents 11:00 AM in the city's LOCAL timezone
        // SunCalc needs a JavaScript Date object representing that exact moment in time
        function createTimestampFromISO(isoTimeString, timezone) {
            // The API already gives us the timestamp in the location's timezone
            // But JavaScript's Date parser will interpret it as LOCAL (browser) time
            // We need to tell it "this time is in THAT timezone"
            
            // Simplest solution: manually build the UTC equivalent
            // Example: Cape Town "2024-12-15T11:00" in Africa/Johannesburg (UTC+2)
            // Should become a Date representing 2024-12-15T09:00:00Z
            
            const date = new Date(isoTimeString);
            
            // Now figure out the offset between the timezone and UTC
            // Create a reference date
            const year = date.getFullYear();
            const month = date.getMonth();
            const day = date.getDate();
            const hour = date.getHours();
            const minute = date.getMinutes();
            
            // Get this moment in the target timezone
            const tzFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            
            // Get this moment in UTC
            const utcFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'UTC',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            
            // Use current moment to calculate offset
            const now = new Date();
            const tzParts = tzFormatter.formatToParts(now);
            const utcParts = utcFormatter.formatToParts(now);
            
            const getValue = (parts, type) => parseInt(parts.find(p => p.type === type)?.value || 0);
            
            const tzHour = getValue(tzParts, 'hour');
            const utcHour = getValue(utcParts, 'hour');
            
            // Calculate offset in hours (this is approximate but works for our purposes)
            let offsetHours = tzHour - utcHour;
            
            // Handle day boundary crossings
            if (offsetHours > 12) offsetHours -= 24;
            if (offsetHours < -12) offsetHours += 24;
            
            // Now apply this offset to our parsed time
            // If Cape Town is UTC+2, and we have 11:00 local, UTC time is 09:00
            // So we subtract the offset
            const utcDate = new Date(Date.UTC(year, month, day, hour - offsetHours, minute, 0));
            
            
            return utcDate;
        }

        function formatTime(time) {
            const hour = time.hour;
            const minute = time.minute.toString().padStart(2, '0');
            if (hour === 0) return `12:${minute} AM`;
            if (hour === 12) return `12:${minute} PM`;
            if (hour < 12) return `${hour}:${minute} AM`;
            return `${hour - 12}:${minute} PM`;
        }

        // ============================================================
        // BRIGHTNESS / SUN PERCEPTION ALGORITHM
        // ============================================================
    
    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        
        const WORKER_URL = 'https://helios.skyler-mydler.workers.dev';
        let API_TOKEN = localStorage.getItem('heliosApiToken') || '';
        let savedCities = JSON.parse(localStorage.getItem('heliosCities') || '[]');
        
            return {
                description: description,
                peakScore: bestScore,
                peakHour: peakHour
            };
        }

        // Search cities
        async function searchCities(query) {
            if (!query || query.length < 2) {
                document.getElementById('searchResults').style.display = 'none';
                return;
            }

            try {
                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=en&format=json`);
                
                if (!response.ok) throw new Error('Search failed');
                
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    displaySearchResults(data.results);
                } else {
                    const resultsDiv = document.getElementById('searchResults');
                    resultsDiv.innerHTML = '<div class="search-result-item" style="color: #999; cursor: default; pointer-events: none;">No cities found</div>';
                    resultsDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Search error:', error);
            }
        }

        function displaySearchResults(results) {
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = results.map((city) => {
                const cityData = JSON.stringify(city).replace(/"/g, '&quot;');
                return `<div class="search-result-item" onclick='addCity(${cityData})'>
                    <strong>${city.name}</strong>
                    <div class="city-details">${city.admin1 ? city.admin1 + ', ' : ''}${city.country}</div>
                </div>`;
            }).join('');
            resultsDiv.style.display = 'block';
        }

        // Add city to saved list
        async function addCity(city) {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchInput').value = '';
            
            // Check if city already exists
            const exists = savedCities.find(c => c.latitude === city.latitude && c.longitude === city.longitude);
            if (exists) {
                renderCityCards();
                return;
            }
            
            // Add city with placeholder data first
            const cityData = {
                name: city.name,
                country: city.country,
                admin1: city.admin1,
                latitude: city.latitude,
                longitude: city.longitude,
                timezone: city.timezone,
                weatherData: null
            };
            
            savedCities.push(cityData);
            renderCityCards();
            
            try {
                const weatherData = await fetchWeatherData(city.latitude, city.longitude, city.timezone);
                cityData.weatherData = weatherData;
                localStorage.setItem('heliosCities', JSON.stringify(savedCities));
                renderCityCards();
            } catch (error) {
                console.error('Failed to fetch weather data:', error);
                const index = savedCities.indexOf(cityData);
                if (index > -1) {
                    savedCities.splice(index, 1);
                }
                renderCityCards();
                alert('Failed to load weather data for ' + city.name + '. Please try again.');
            }
        }

        // Fetch weather data - use Weather.gov for US, Open-Meteo for international
        async function fetchWeatherData(lat, lon, timezone) {
            // Check if coordinates are in USA
            const isUS = lat >= 24.5 && lat <= 49.4 && lon >= -125 && lon <= -66;
            
            if (isUS) {
                try {
                    console.log('Attempting Weather.gov API for US location...');
                    
                    // Get grid point data
                    const pointsUrl = `https://api.weather.gov/points/${lat.toFixed(4)},${lon.toFixed(4)}`;
                    const pointsResponse = await fetch(pointsUrl);
                    
                    if (pointsResponse.ok) {
                        const pointsData = await pointsResponse.json();
                        const forecastHourlyUrl = pointsData.properties.forecastHourly;
                        
                        // Get hourly forecast
                        const hourlyResponse = await fetch(forecastHourlyUrl);
                        
                        if (hourlyResponse.ok) {
                            const hourlyData = await hourlyResponse.json();
                            console.log('Weather.gov data retrieved successfully');
                            
                            // Convert Weather.gov format to our expected format
                            const converted = convertWeatherGovData(hourlyData, timezone);
                            
                            // Still need sunrise/sunset from Open-Meteo
                            const sunUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=sunrise,sunset,temperature_2m_max,temperature_2m_min&timezone=${encodeURIComponent(timezone)}`;
                            const sunResponse = await fetch(sunUrl);
                            const sunData = await sunResponse.json();
                            
                            converted.daily = sunData.daily;
                            
                            return converted;
                        }
                    }
                    
                    console.log('Weather.gov failed, falling back to Open-Meteo');
                } catch (error) {
                    console.log('Weather.gov error:', error.message, '- using Open-Meteo');
                }
            }
            
            // Fallback to Open-Meteo (or primary for non-US)
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,cloud_cover,precipitation,weather_code&daily=sunrise,sunset,temperature_2m_max,temperature_2m_min&temperature_unit=fahrenheit&timezone=${encodeURIComponent(timezone)}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            return data;
        }
        
        // Convert Weather.gov format to Open-Meteo format
        function convertWeatherGovData(weatherGovData, timezone) {
            const periods = weatherGovData.properties.periods;
            
            const converted = {
                hourly: {
                    time: [],
                    temperature_2m: [],
                    cloud_cover: [],
                    precipitation: [],
                    weather_code: []
                }
            };
            
            periods.forEach(period => {
                // Time
                converted.hourly.time.push(period.startTime.split('T')[0] + 'T' + period.startTime.split('T')[1].split('-')[0].split('+')[0].substring(0, 5));
                
                // Temperature
                converted.hourly.temperature_2m.push(period.temperature);
                
                // Cloud cover estimation from shortForecast
                const forecast = period.shortForecast.toLowerCase();
                let cloudCover = 50;
                if (forecast.includes('sunny') || forecast.includes('clear')) cloudCover = 5;
                else if (forecast.includes('mostly clear') || forecast.includes('mostly sunny')) cloudCover = 15;
                else if (forecast.includes('partly cloudy') || forecast.includes('partly sunny')) cloudCover = 40;
                else if (forecast.includes('mostly cloudy')) cloudCover = 75;
                else if (forecast.includes('cloudy') || forecast.includes('overcast')) cloudCover = 90;
                converted.hourly.cloud_cover.push(cloudCover);
                
                // Precipitation (Weather.gov gives probability, convert to amount estimate)
                const precipProb = period.probabilityOfPrecipitation?.value || 0;
                converted.hourly.precipitation.push(precipProb > 50 ? 0.1 : 0);
                
                // Weather code mapping
                let weatherCode = 1; // default: mainly clear
                if (forecast.includes('sunny') || forecast.includes('clear')) weatherCode = 0;
                else if (forecast.includes('partly')) weatherCode = 2;
                else if (forecast.includes('cloudy') || forecast.includes('overcast')) weatherCode = 3;
                else if (forecast.includes('fog')) weatherCode = 45;
                else if (forecast.includes('drizzle')) weatherCode = 51;
                else if (forecast.includes('rain') && !forecast.includes('thunder')) weatherCode = 61;
                else if (forecast.includes('snow')) weatherCode = 71;
                else if (forecast.includes('thunder')) weatherCode = 95;
                converted.hourly.weather_code.push(weatherCode);
            });
            
            return converted;
        }

        // Render city cards
        // ============================================================
        // CLOUDFLARE WORKER API
        // ============================================================
        
        async function fetchScoresFromWorker(lat, lon, cityName) {
            try {
                // Check for token
                if (!API_TOKEN) {
                    API_TOKEN = prompt('üîê Enter your Helios API token:\n\n(You only need to do this once)');
                    if (!API_TOKEN) {
                        return null;
                    }
                    localStorage.setItem('heliosApiToken', API_TOKEN);
                }
                
                console.log('Fetching scores from Worker for:', cityName);
                
                const response = await fetch(`${WORKER_URL}/calculate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_TOKEN}`
                    },
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lon,
                        cityName: cityName
                    })
                });
                
                if (response.status === 401) {
                    // Invalid token
                    localStorage.removeItem('heliosApiToken');
                    API_TOKEN = '';
                    alert('‚ùå Invalid API token. Please enter a valid token.');
                    return await fetchScoresFromWorker(lat, lon, cityName);
                }
                
                if (!response.ok) {
                    throw new Error(`Worker API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Received scores:', data);
                return data;
                
            } catch (error) {
                console.error('‚ùå Worker API error:', error);
                alert('Unable to load weather data. Please check your connection.');
                return null;
            }
        }
        
        // ============================================================
        // CITY RENDERING
        // ============================================================
        
        async function renderCityCards() {
            const citiesGrid = document.getElementById('citiesGrid');
            const emptyState = document.getElementById('emptyState');
            
            if (savedCities.length === 0) {
                emptyState.style.display = 'block';
                citiesGrid.innerHTML = '';
                return;
            }
            
            emptyState.style.display = 'none';
            citiesGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: white; font-size: 18px;">‚òÄÔ∏è Loading scores...</div>';
            
            const cards = [];
            
            for (let index = 0; index < savedCities.length; index++) {
                const city = savedCities[index];
                
                // Fetch from Worker
                const scores = await fetchScoresFromWorker(city.latitude, city.longitude, city.name);
                
                if (!scores) {
                    cards.push(`
                        <div class="city-card" style="opacity: 0.5;">
                            <div class="city-name">${city.name}</div>
                            <div style="color: #666;">Failed to load</div>
                        </div>
                    `);
                    continue;
                }
                
                const score = scores.currentScore || 0;
                const temp = scores.currentTemp || 0;
                const daily = scores.dailyAverage || 0;
                
                cards.push(`
                    <div class="city-card" onclick="showCityDetail(savedCities[${index}])" style="position: relative; cursor: pointer;">
                        <button class="delete-city" onclick="event.stopPropagation(); deleteCity(${index})">&times;</button>
                        <div class="city-card-header">
                            <div class="city-info">
                                <div class="city-name">${city.name}</div>
                                <div class="city-country">${city.admin1 ? city.admin1 + ', ' : ''}${city.country || ''}</div>
                            </div>
                            <div class="helio-score-circle ${score > 0 ? getScoreColorClass(score) : 'night'}" data-score="${score > 0 ? score.toFixed(1) : 'N/A'}">
                                ${score > 0 ? score.toFixed(1) : 'N/A'}
                            </div>
                        </div>
                        <div class="city-stats">
                            <div class="stat">
                                <div class="stat-label">Current</div>
                                <div class="stat-value">${getScoreLabel(score)}</div>
                            </div>
                            <div class="stat">
                                <div class="stat-label">Temperature</div>
                                <div class="stat-value">${temp}¬∞F</div>
                            </div>
                            <div class="stat">
                                <div class="stat-label">Daily Avg</div>
                                <div class="stat-value">${daily > 0 ? daily.toFixed(1) : 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `);
            }
            
            citiesGrid.innerHTML = cards.join('');
        }
        
        async function showCityDetail(city) {
            // Fetch detailed scores
            const scores = await fetchScoresFromWorker(city.latitude, city.longitude, city.name);
            
            if (!scores) return;
            
            // Show detail view
            document.getElementById('citiesView').style.display = 'none';
            document.getElementById('detailView').style.display = 'block';
            document.getElementById('backButton').style.display = 'block';
            
            // Populate detail view
            document.getElementById('detailCityName').textContent = city.name;
            document.getElementById('detailHelioScore').textContent = scores.currentScore > 0 ? scores.currentScore.toFixed(1) : 'N/A';
            document.getElementById('detailScoreLabel').textContent = getScoreLabel(scores.currentScore);
            
            // Current conditions
            const detailGrid = document.querySelector('.detail-grid');
            detailGrid.innerHTML = `
                <div class="detail-item">
                    <div class="detail-label">Temperature</div>
                    <div class="detail-value">${scores.currentTemp}¬∞F</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Conditions</div>
                    <div class="detail-value">${getWeatherLabel(scores.currentWeatherCode)}</div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Daily Average</div>
                    <div class="detail-value">${scores.dailyAverage > 0 ? scores.dailyAverage.toFixed(1) : 'N/A'}</div>
                </div>
            `;
            
            // Hourly forecast
            const hourlyGrid = document.querySelector('.hourly-grid');
            hourlyGrid.innerHTML = scores.hourlyForecast.slice(0, 24).map(h => {
                const time = new Date(h.time);
                const timeStr = time.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true });
                return `
                    <div class="hourly-item">
                        <div class="hourly-time">${timeStr}</div>
                        <div class="hourly-icon">${getWeatherIcon(h.weatherCode)}</div>
                        <div class="hourly-score ${h.score > 0 ? getScoreColorClass(h.score) : 'night'}">${h.score > 0 ? h.score.toFixed(1) : 'N/A'}</div>
                        <div class="hourly-temp">${h.temperature}¬∞F</div>
                    </div>
                `;
            }).join('');
            
            // 7-day forecast
            const forecastList = document.querySelector('.forecast-list');
            forecastList.innerHTML = scores.weekForecast.map(day => {
                const date = new Date(day.date);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
                const isToday = dayName === new Date().toLocaleDateString('en-US', { weekday: 'short' });
                return `
                    <div class="forecast-day">
                        <div>
                            <div style="font-weight: 600;">${isToday ? 'Today' : dayName}</div>
                            <div style="font-size: 13px; color: #666;">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div>
                        </div>
                        <div class="forecast-score ${day.avgScore > 0 ? getScoreColorClass(day.avgScore) : ''}">${day.avgScore > 0 ? day.avgScore.toFixed(1) : 'N/A'}</div>
                        <div>${day.maxTemp}¬∞F / ${day.minTemp}¬∞F ¬∑ ${getScoreLabel(day.avgScore)}</div>
                    </div>
                `;
            }).join('');
        }
        
        function showCitiesView() {
            document.getElementById('citiesView').style.display = 'block';
            document.getElementById('detailView').style.display = 'none';
            document.getElementById('backButton').style.display = 'none';
        }
        
        function deleteCity(index) {
            savedCities.splice(index, 1);
            localStorage.setItem('heliosCities', JSON.stringify(savedCities));
            renderCityCards();
        }
        
        // ============================================================
        // SEARCH FUNCTIONALITY
        // ============================================================
        
        async function searchCities(query) {
            if (!query || query.length < 2) {
                document.getElementById('searchResults').style.display = 'none';
                return;
            }
            
            try {
                const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=en&format=json`);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const resultsDiv = document.getElementById('searchResults');
                    resultsDiv.innerHTML = data.results.map(city => {
                        const cityJSON = JSON.stringify(city).replace(/"/g, '&quot;');
                        return `
                            <div class="search-result-item" onclick='addCity(${cityJSON})'>
                                <strong>${city.name}</strong>
                                <div class="city-details">${city.admin1 ? city.admin1 + ', ' : ''}${city.country}</div>
                            </div>
                        `;
                    }).join('');
                    resultsDiv.style.display = 'block';
                } else {
                    const resultsDiv = document.getElementById('searchResults');
                    resultsDiv.innerHTML = '<div class="search-result-item" style="color: #999;">No cities found</div>';
                    resultsDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        function addCity(city) {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchInput').value = '';
            
            // Check if already exists
            const exists = savedCities.find(c => c.latitude === city.latitude && c.longitude === city.longitude);
            if (exists) {
                renderCityCards();
                return;
            }
            
            // Add city
            savedCities.push({
                name: city.name,
                country: city.country,
                admin1: city.admin1,
                latitude: city.latitude,
                longitude: city.longitude,
                timezone: city.timezone
            });
            
            localStorage.setItem('heliosCities', JSON.stringify(savedCities));
            renderCityCards();
        }
        
        // ============================================================
        // INITIALIZATION
        // ============================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            renderCityCards();
            
            // Search input listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', (e) => {
                searchCities(e.target.value);
            });
            
            // Search button
            document.getElementById('searchBtn').addEventListener('click', () => {
                searchCities(searchInput.value);
            });
            
            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-container')) {
                    document.getElementById('searchResults').style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
